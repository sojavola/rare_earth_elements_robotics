
from langchain_mistralai.chat_models import ChatMistralAI
from langchain.schema import HumanMessage, SystemMessage
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from langchain.schema import BaseOutputParser
import json
import pandas as pd
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
import seaborn as sns
import requests
import os

from .api_config import config_manager

class ScienceAISystem:
    def __init__(self, mistral_api_key=None, model_name=None):
        # Configuration depuis le gestionnaire de config
        self.config = config_manager.get_model_config()
        
        # Utiliser la cl√© API fournie ou celle de la config
        api_key = mistral_api_key or config_manager.get_api_key()
        model_name = model_name or self.config.get('model', 'mistral-large-latest')
        
        if api_key and api_key != 'xiIZeHKEkdJHh72eLzDQvFuQnKgDg5im':
            try:
                self.llm = ChatMistralAI(
                    model=model_name,
                    mistral_api_key=api_key,
                    temperature=self.config.get('temperature', 0.7),
                    max_tokens=self.config.get('max_tokens', 2000)
                )
                self.api_available = True
                print("‚úÖ Mistral AI API configur√©e avec succ√®s")
            except Exception as e:
                print(f"‚ùå Erreur configuration Mistral AI: {e}")
                self.llm = None
                self.api_available = False
        else:
            self.llm = None
            self.api_available = False
            print("‚ö†Ô∏è Cl√© API Mistral non configur√©e")
        
        # Templates de prompts
        self.prompt_templates = self._initialize_prompt_templates()
        
        # Historique des missions
        self.mission_history = []
        
        # Cache pour les r√©ponses fr√©quentes
        self.response_cache = {}
    
    def _initialize_prompt_templates(self):
        """Initialise les templates de prompts pour diff√©rentes t√¢ches"""
        return {
            'mission_analysis': PromptTemplate(
                input_variables=["mineral_data", "exploration_data", "science_stats"],
                template="""
                ROLE: Expert en g√©ologie plan√©taire et exploration robotique
                CONTEXTE: Mission d'exploration de terres rares sur corps c√©leste
                DONN√âES: 
                Min√©raux: {mineral_data}
                Exploration: {exploration_data} 
                Statistiques: {science_stats}

                T√ÇCHE: Fournir une analyse scientifique compl√®te incluant:
                1. Potentiel en terres rares de la zone
                2. Min√©raux les plus prometteurs
                3. Recommandations d'exploration
                4. Implications pour l'extraction spatiale

                FORMAT: Fran√ßais scientifique professionnel
                """
            ),
            
            'mission_report': PromptTemplate(
                input_variables=["mission_data", "discoveries", "recommendations"],
                template="""
                G√âN√âRER: Rapport de mission scientifique professionnel
                DONN√âES: {mission_data}
                D√âCOUVERTES: {discoveries}
                RECOMMANDATIONS: {recommendations}

                SECTIONS REQUISES:
                - R√©sum√© ex√©cutif
                - M√©thodologie d'exploration  
                - R√©sultats scientifiques
                - Analyse g√©ologique
                - Recommandations futures
                - Conclusion

                STYLE: Formel et scientifique en fran√ßais
                """
            ),
            
            'real_time_advice': PromptTemplate(
                input_variables=["current_state", "recent_discoveries", "mission_goals"],
                template="""
                R√îLE: Conseiller scientifique temps r√©el
                √âTAT: {current_state}
                D√âCOUVERTES: {recent_discoveries}
                OBJECTIFS: {mission_goals}

                CONSEILS √Ä FOURNIR:
                - Zones √† explorer
                - Instruments √† prioriser  
                - Risques √† √©viter
                - Opportunit√©s scientifiques

                FORMAT: Conseils pratiques en fran√ßais
                """
            ),
            
            'mineral_classification': PromptTemplate(
                input_variables=["spectral_data", "context"],
                template="""
                EXPERTISE: G√©ologie des terres rares
                DONN√âES SPECTRALES: {spectral_data}
                CONTEXTE: {context}

                ANALYSE REQUISE:
                1. Classification min√©rale
                2. Niveau de confiance
                3. Caract√©ristiques distinctives
                4. Implications exploration

                FORMAT: Technique mais accessible en fran√ßais
                """
            ),
            
            'emergency_protocol': PromptTemplate(
                input_variables=["emergency_type", "situation", "resources"],
                template="""
                URGENCE: {emergency_type}
                SITUATION: {situation}
                RESSOURCES: {resources}

                PROTOCOLE √Ä SUIVRE:
                1. Actions imm√©diates
                2. Priorit√©s de s√©curit√©
                3. Communication
                4. Plan de recovery

                FORMAT: Instructions claires et concises en fran√ßais
                """
            )
        }
    
    def _call_mistral_api(self, prompt, cache_key=None):
        """Appelle l'API Mistral avec gestion de cache"""
        if cache_key and cache_key in self.response_cache:
            return self.response_cache[cache_key]
        
        if not self.llm:
            return "Syst√®me IA non configur√©. V√©rifiez la cl√© API Mistral."
        
        try:
            response = self.llm.invoke([HumanMessage(content=prompt)])
            result = response.content
            
            if cache_key:
                self.response_cache[cache_key] = result
            
            return result
        except Exception as e:
            error_msg = f"Erreur API Mistral: {str(e)}"
            print(f"‚ùå {error_msg}")
            return error_msg
    
    def analyze_mission_data(self, mineral_map, exploration_data, science_stats):
        """Analyse les donn√©es de mission avec Mistral AI"""
        cache_key = f"analysis_{hash(str(mineral_map))}_{hash(str(exploration_data))}"
        
        if not self.api_available:
            return self._get_fallback_analysis(mineral_map, exploration_data, science_stats)
        
        # Pr√©paration des donn√©es
        mineral_summary = self._summarize_mineral_data(mineral_map)
        exploration_summary = self._summarize_exploration_data(exploration_data)
        stats_summary = self._summarize_science_stats(science_stats)
        
        # Construction du prompt
        prompt = f"""
        ANALYSE MISSION EXPLORATION TERRES RARES
        
        CARTE MIN√âRALE:
        {mineral_summary}

        PROGRESSION EXPLORATION:
        {exploration_summary}

        STATISTIQUES SCIENTIFIQUES:
        {stats_summary}

        FOURNIR:
        - √âvaluation potentiel terres rares
        - Min√©raux prioritaires identifi√©s  
        - Strat√©gie exploration recommand√©e
        - Implications extraction spatiale

        FORMAT: Rapport scientifique fran√ßais d√©taill√©
        """
        
        # Appel API
        analysis = self._call_mistral_api(prompt, cache_key)
        
        # Enregistrement dans l'historique
        mission_record = {
            'timestamp': datetime.now().isoformat(),
            'type': 'mission_analysis',
            'mineral_data': mineral_summary,
            'exploration_data': exploration_summary,
            'science_stats': stats_summary,
            'ai_analysis': analysis
        }
        self.mission_history.append(mission_record)
        
        return analysis
    
    def generate_mission_report(self, mission_data, discoveries, recommendations):
        """G√©n√®re un rapport de mission complet"""
        cache_key = f"report_{hash(str(mission_data))}"
        
        if not self.api_available:
            return self._get_fallback_report(mission_data, discoveries, recommendations)
        
        prompt = f"""
        G√âN√âRATION RAPPORT MISSION SCIENTIFIQUE
        
        DONN√âES MISSION: {mission_data}
        D√âCOUVERTES MAJEURES: {discoveries} 
        RECOMMANDATIONS: {recommendations}

        STRUCTURE:
        1. R√©sum√© Ex√©cutif
        2. Contexte Mission
        3. M√©thodologie Exploration
        4. R√©sultats Scientifiques
        5. Analyse G√©ologique
        6. Recommandations Strat√©giques
        7. Conclusion et Perspectives

        STYLE: Professionnel, scientifique, fran√ßais
        """
        
        report = self._call_mistral_api(prompt, cache_key)
        
        # Enregistrement
        self.mission_history.append({
            'timestamp': datetime.now().isoformat(),
            'type': 'mission_report',
            'report': report
        })
        
        return report
    
    def get_real_time_advice(self, current_state, recent_discoveries, mission_goals):
        """Obtient des conseils en temps r√©el pour l'exploration"""
        cache_key = f"advice_{hash(current_state)}_{hash(recent_discoveries)}"
        
        if not self.api_available:
            return self._get_fallback_advice(current_state, recent_discoveries, mission_goals)
        
        prompt = f"""
        CONSEILS EXPLORATION TEMPS R√âEL
        
        √âTAT ACTUEL: {current_state}
        D√âCOUVERTES R√âCENTES: {recent_discoveries}
        OBJECTIFS MISSION: {mission_goals}

        CONSEILS REQUIS:
        - Zones exploration prioritaires
        - Allocation ressources robots
        - Strat√©gies √©vitement risques
        - Optimisation collecte donn√©es

        FORMAT: Points actionnables en fran√ßais
        """
        
        return self._call_mistral_api(prompt, cache_key)
    
    def classify_mineral_from_spectral(self, spectral_data, context=""):
        """Classifie les min√©raux bas√© sur les donn√©es spectrales"""
        cache_key = f"classification_{hash(spectral_data)}"
        
        if not self.api_available:
            return self._get_fallback_classification(spectral_data, context)
        
        prompt = f"""
        CLASSIFICATION MIN√âRALE SPECTRALE
        
        DONN√âES SPECTRALES: {spectral_data}
        CONTEXTE G√âOLOGIQUE: {context}

        ANALYSE REQUISE:
        - Type min√©ral probable
        - Indices de confiance
        - Caract√©ristiques identification
        - Implications exploration

        FORMAT: Analyse technique en fran√ßais
        """
        
        return self._call_mistral_api(prompt, cache_key)
    
    def emergency_protocol(self, emergency_type, situation, available_resources):
        """G√©n√®re un protocole d'urgence"""
        prompt = f"""
        PROTOCOLE URGENCE EXPLORATION SPATIALE
        
        TYPE URGENCE: {emergency_type}
        SITUATION: {situation}
        RESSOURCES DISPONIBLES: {available_resources}

        √âLABORER:
        1. Actions imm√©diates de s√©curit√©
        2. Priorit√©s pr√©servation mission
        3. Communication situation
        4. Plan recovery op√©rations

        FORMAT: Instructions claires √©tape par √©tape
        """
        
        return self._call_mistral_api(prompt)
    
    def _get_fallback_analysis(self, mineral_map, exploration_data, science_stats):
        """Analyse de repli si l'API n'est pas disponible"""
        mineral_summary = self._summarize_mineral_data(mineral_map)
        
        return f"""
        ‚ö†Ô∏è ANALYSE LOCALE (API MISTRAL NON DISPONIBLE)
        
        CARTE MIN√âRALE:
        {mineral_summary}
        
        STRAT√âGIE RECOMMAND√âE:
        1. Explorer zones concentration >0.5
        2. Prioriser robots vers r√©gions inexplor√©es
        3. √âchantillonnage syst√©matique crat√®res
        4. Coordination multi-robots optimis√©e
        
        RISQUES IDENTIFI√âS:
        - Couverture exploration insuffisante
        - Ressources √©nergie limit√©es
        - Communication inter-robots
        """
    
    def _get_fallback_advice(self, current_state, recent_discoveries, mission_goals):
        """Conseils de repli"""
        return """
        CONSEILS STRAT√âGIQUES (MODE LOCAL):
        
        üîç EXPLORATION:
        - Cibler zones adjacentes d√©couvertes
        - Balayage syst√©matique secteurs
        - Prioriser crat√®res et formations
        
        üìä OPTIMISATION:
        - Rotation robots zones chaudes
        - Conservation √©nergie d√©placements
        - Communication donn√©es essentielles
        
        ‚ö†Ô∏è VIGILANCE:
        - Surveillance niveaux batterie
        - √âviter zones obstacles denses
        - Maintenir couverture communication
        """
    
    def _summarize_mineral_data(self, mineral_map):
        """R√©sume les donn√©es min√©rales pour l'IA"""
        if isinstance(mineral_map, np.ndarray):
            total_minerals = np.sum(mineral_map > 0.1)
            max_concentration = np.max(mineral_map)
            avg_concentration = np.mean(mineral_map[mineral_map > 0])
            
            if mineral_map.ndim == 3:
                mineral_types = ["REE_Oxides", "REE_Silicates", "REE_Phosphates", "REE_Carbonates"]
                type_summary = []
                for i, mineral_type in enumerate(mineral_types):
                    if i < mineral_map.shape[2]:
                        count = np.sum(mineral_map[:, :, i] > 0.1)
                        max_conc = np.max(mineral_map[:, :, i])
                        type_summary.append(f"{mineral_type}: {count} pts, max:{max_conc:.3f}")
            else:
                type_summary = ["Donn√©es non disponibles"]
            
            return f"""
            üìä CARTE MIN√âRALE:
            ‚Ä¢ Points d√©tect√©s: {total_minerals}
            ‚Ä¢ Concentration max: {max_concentration:.3f}
            ‚Ä¢ Concentration moy: {avg_concentration:.3f}
            ‚Ä¢ Distribution: {mineral_map.shape}
            
            üî¨ R√âPARTITION:
            {chr(10).join(type_summary)}
            """
        else:
            return f"Donn√©es min√©rales: {str(mineral_map)}"
    
    def _summarize_exploration_data(self, exploration_data):
        """R√©sume les donn√©es d'exploration"""
        if isinstance(exploration_data, dict):
            return f"""
            üöÄ PROGRESSION EXPLORATION:
            ‚Ä¢ Zone couverte: {exploration_data.get('area_covered', 'N/A')}%
            ‚Ä¢ Distance: {exploration_data.get('distance_traveled', 'N/A')}m
            ‚Ä¢ Temps: {exploration_data.get('exploration_time', 'N/A')}min
            ‚Ä¢ Positions: {exploration_data.get('positions_visited', 'N/A')}
            ‚Ä¢ Robots: {exploration_data.get('active_robots', 'N/A')}
            ‚Ä¢ Taux d√©couverte: {exploration_data.get('discovery_rate', 'N/A')}%
            """
        else:
            return str(exploration_data)
    
    def _summarize_science_stats(self, science_stats):
        """R√©sume les statistiques scientifiques"""
        if isinstance(science_stats, dict):
            return f"""
            üîç STATISTIQUES SCIENTIFIQUES:
            ‚Ä¢ Min√©raux: {science_stats.get('discovered_minerals', 0)}
            ‚Ä¢ √âchantillons HV: {science_stats.get('high_value_samples', 0)}
            ‚Ä¢ R√©gions: {science_stats.get('visited_regions', 0)}
            ‚Ä¢ Score science: {science_stats.get('total_science_value', 0):.1f}
            ‚Ä¢ Min√©raux uniques: {science_stats.get('unique_minerals', 0)}
            ‚Ä¢ Concentration moy: {science_stats.get('avg_concentration', 0):.3f}
            """
        else:
            return str(science_stats)
    
    def get_system_status(self):
        """Retourne le statut du syst√®me"""
        if self.api_available:
            model = self.config.get('model', 'N/A')
            return f"üü¢ MISTRAL AI ONLINE - Mod√®le: {model}"
        else:
            return "üî¥ MISTRAL AI OFFLINE - Cl√© API requise"
    
    def export_mission_data(self, filepath=None):
        """Exporte toutes les donn√©es de mission"""
        if not filepath:
            filepath = f"/tmp/ree_mission_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        export_data = {
            'export_timestamp': datetime.now().isoformat(),
            'system_status': self.get_system_status(),
            'mission_history': self.mission_history,
            'config': self.config
        }
        
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False)
            return f"‚úÖ Donn√©es export√©es: {filepath}"
        except Exception as e:
            return f"‚ùå Erreur export: {str(e)}"
    
    def clear_cache(self):
        """Vide le cache des r√©ponses"""
        self.response_cache.clear()
        return "‚úÖ Cache vid√©"

# Test du syst√®me
def test_system():
    """Teste le syst√®me Mistral AI"""
    print("üß™ Test du syst√®me Generative AI...")
    
    ai_system = ScienceAISystem()
    print(ai_system.get_system_status())
    
    # Test avec donn√©es simul√©es
    if ai_system.api_available:
        test_data = np.random.rand(10, 10, 4) * 0.6
        exploration = {'area_covered': 45, 'active_robots': 3}
        stats = {'discovered_minerals': 12, 'high_value_samples': 2}
        
        analysis = ai_system.analyze_mission_data(test_data, exploration, stats)
        print(f"üìù Analyse test: {analysis[:200]}...")
    
    return ai_system

if __name__ == "__main__":
    test_system()