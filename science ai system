
from langchain_mistralai.chat_models import ChatMistralAI
from langchain.schema import HumanMessage, SystemMessage
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from langchain.schema import BaseOutputParser
import json
import pandas as pd
import numpy as np
from datetime import datetime
import matplotlib.pyplot as plt
import seaborn as sns
import requests
import os

from .api_config import config_manager

class ScienceAISystem:
    def __init__(self, mistral_api_key=None, model_name=None):
        # Configuration depuis le gestionnaire de config
        self.config = config_manager.get_model_config()
        
        # Utiliser la clé API fournie ou celle de la config
        api_key = mistral_api_key or config_manager.get_api_key()
        model_name = model_name or self.config.get('model', 'mistral-large-latest')
        
        if api_key and api_key != 'xiIZeHKEkdJHh72eLzDQvFuQnKgDg5im':
            try:
                self.llm = ChatMistralAI(
                    model=model_name,
                    mistral_api_key=api_key,
                    temperature=self.config.get('temperature', 0.7),
                    max_tokens=self.config.get('max_tokens', 2000)
                )
                self.api_available = True
                print("✅ Mistral AI API configurée avec succès")
            except Exception as e:
                print(f"❌ Erreur configuration Mistral AI: {e}")
                self.llm = None
                self.api_available = False
        else:
            self.llm = None
            self.api_available = False
            print("⚠️ Clé API Mistral non configurée")
        
        # Templates de prompts
        self.prompt_templates = self._initialize_prompt_templates()
        
        # Historique des missions
        self.mission_history = []
        
        # Cache pour les réponses fréquentes
        self.response_cache = {}
    
    def _initialize_prompt_templates(self):
        """Initialise les templates de prompts pour différentes tâches"""
        return {
            'mission_analysis': PromptTemplate(
                input_variables=["mineral_data", "exploration_data", "science_stats"],
                template="""
                ROLE: Expert en géologie planétaire et exploration robotique
                CONTEXTE: Mission d'exploration de terres rares sur corps céleste
                DONNÉES: 
                Minéraux: {mineral_data}
                Exploration: {exploration_data} 
                Statistiques: {science_stats}

                TÂCHE: Fournir une analyse scientifique complète incluant:
                1. Potentiel en terres rares de la zone
                2. Minéraux les plus prometteurs
                3. Recommandations d'exploration
                4. Implications pour l'extraction spatiale

                FORMAT: Français scientifique professionnel
                """
            ),
            
            'mission_report': PromptTemplate(
                input_variables=["mission_data", "discoveries", "recommendations"],
                template="""
                GÉNÉRER: Rapport de mission scientifique professionnel
                DONNÉES: {mission_data}
                DÉCOUVERTES: {discoveries}
                RECOMMANDATIONS: {recommendations}

                SECTIONS REQUISES:
                - Résumé exécutif
                - Méthodologie d'exploration  
                - Résultats scientifiques
                - Analyse géologique
                - Recommandations futures
                - Conclusion

                STYLE: Formel et scientifique en français
                """
            ),
            
            'real_time_advice': PromptTemplate(
                input_variables=["current_state", "recent_discoveries", "mission_goals"],
                template="""
                RÔLE: Conseiller scientifique temps réel
                ÉTAT: {current_state}
                DÉCOUVERTES: {recent_discoveries}
                OBJECTIFS: {mission_goals}

                CONSEILS À FOURNIR:
                - Zones à explorer
                - Instruments à prioriser  
                - Risques à éviter
                - Opportunités scientifiques

                FORMAT: Conseils pratiques en français
                """
            ),
            
            'mineral_classification': PromptTemplate(
                input_variables=["spectral_data", "context"],
                template="""
                EXPERTISE: Géologie des terres rares
                DONNÉES SPECTRALES: {spectral_data}
                CONTEXTE: {context}

                ANALYSE REQUISE:
                1. Classification minérale
                2. Niveau de confiance
                3. Caractéristiques distinctives
                4. Implications exploration

                FORMAT: Technique mais accessible en français
                """
            ),
            
            'emergency_protocol': PromptTemplate(
                input_variables=["emergency_type", "situation", "resources"],
                template="""
                URGENCE: {emergency_type}
                SITUATION: {situation}
                RESSOURCES: {resources}

                PROTOCOLE À SUIVRE:
                1. Actions immédiates
                2. Priorités de sécurité
                3. Communication
                4. Plan de recovery

                FORMAT: Instructions claires et concises en français
                """
            )
        }
    
    def _call_mistral_api(self, prompt, cache_key=None):
        """Appelle l'API Mistral avec gestion de cache"""
        if cache_key and cache_key in self.response_cache:
            return self.response_cache[cache_key]
        
        if not self.llm:
            return "Système IA non configuré. Vérifiez la clé API Mistral."
        
        try:
            response = self.llm.invoke([HumanMessage(content=prompt)])
            result = response.content
            
            if cache_key:
                self.response_cache[cache_key] = result
            
            return result
        except Exception as e:
            error_msg = f"Erreur API Mistral: {str(e)}"
            print(f"❌ {error_msg}")
            return error_msg
    
    def analyze_mission_data(self, mineral_map, exploration_data, science_stats):
        """Analyse les données de mission avec Mistral AI"""
        cache_key = f"analysis_{hash(str(mineral_map))}_{hash(str(exploration_data))}"
        
        if not self.api_available:
            return self._get_fallback_analysis(mineral_map, exploration_data, science_stats)
        
        # Préparation des données
        mineral_summary = self._summarize_mineral_data(mineral_map)
        exploration_summary = self._summarize_exploration_data(exploration_data)
        stats_summary = self._summarize_science_stats(science_stats)
        
        # Construction du prompt
        prompt = f"""
        ANALYSE MISSION EXPLORATION TERRES RARES
        
        CARTE MINÉRALE:
        {mineral_summary}

        PROGRESSION EXPLORATION:
        {exploration_summary}

        STATISTIQUES SCIENTIFIQUES:
        {stats_summary}

        FOURNIR:
        - Évaluation potentiel terres rares
        - Minéraux prioritaires identifiés  
        - Stratégie exploration recommandée
        - Implications extraction spatiale

        FORMAT: Rapport scientifique français détaillé
        """
        
        # Appel API
        analysis = self._call_mistral_api(prompt, cache_key)
        
        # Enregistrement dans l'historique
        mission_record = {
            'timestamp': datetime.now().isoformat(),
            'type': 'mission_analysis',
            'mineral_data': mineral_summary,
            'exploration_data': exploration_summary,
            'science_stats': stats_summary,
            'ai_analysis': analysis
        }
        self.mission_history.append(mission_record)
        
        return analysis
    
    def generate_mission_report(self, mission_data, discoveries, recommendations):
        """Génère un rapport de mission complet"""
        cache_key = f"report_{hash(str(mission_data))}"
        
        if not self.api_available:
            return self._get_fallback_report(mission_data, discoveries, recommendations)
        
        prompt = f"""
        GÉNÉRATION RAPPORT MISSION SCIENTIFIQUE
        
        DONNÉES MISSION: {mission_data}
        DÉCOUVERTES MAJEURES: {discoveries} 
        RECOMMANDATIONS: {recommendations}

        STRUCTURE:
        1. Résumé Exécutif
        2. Contexte Mission
        3. Méthodologie Exploration
        4. Résultats Scientifiques
        5. Analyse Géologique
        6. Recommandations Stratégiques
        7. Conclusion et Perspectives

        STYLE: Professionnel, scientifique, français
        """
        
        report = self._call_mistral_api(prompt, cache_key)
        
        # Enregistrement
        self.mission_history.append({
            'timestamp': datetime.now().isoformat(),
            'type': 'mission_report',
            'report': report
        })
        
        return report
    
    def get_real_time_advice(self, current_state, recent_discoveries, mission_goals):
        """Obtient des conseils en temps réel pour l'exploration"""
        cache_key = f"advice_{hash(current_state)}_{hash(recent_discoveries)}"
        
        if not self.api_available:
            return self._get_fallback_advice(current_state, recent_discoveries, mission_goals)
        
        prompt = f"""
        CONSEILS EXPLORATION TEMPS RÉEL
        
        ÉTAT ACTUEL: {current_state}
        DÉCOUVERTES RÉCENTES: {recent_discoveries}
        OBJECTIFS MISSION: {mission_goals}

        CONSEILS REQUIS:
        - Zones exploration prioritaires
        - Allocation ressources robots
        - Stratégies évitement risques
        - Optimisation collecte données

        FORMAT: Points actionnables en français
        """
        
        return self._call_mistral_api(prompt, cache_key)
    
    def classify_mineral_from_spectral(self, spectral_data, context=""):
        """Classifie les minéraux basé sur les données spectrales"""
        cache_key = f"classification_{hash(spectral_data)}"
        
        if not self.api_available:
            return self._get_fallback_classification(spectral_data, context)
        
        prompt = f"""
        CLASSIFICATION MINÉRALE SPECTRALE
        
        DONNÉES SPECTRALES: {spectral_data}
        CONTEXTE GÉOLOGIQUE: {context}

        ANALYSE REQUISE:
        - Type minéral probable
        - Indices de confiance
        - Caractéristiques identification
        - Implications exploration

        FORMAT: Analyse technique en français
        """
        
        return self._call_mistral_api(prompt, cache_key)
    
    def emergency_protocol(self, emergency_type, situation, available_resources):
        """Génère un protocole d'urgence"""
        prompt = f"""
        PROTOCOLE URGENCE EXPLORATION SPATIALE
        
        TYPE URGENCE: {emergency_type}
        SITUATION: {situation}
        RESSOURCES DISPONIBLES: {available_resources}

        ÉLABORER:
        1. Actions immédiates de sécurité
        2. Priorités préservation mission
        3. Communication situation
        4. Plan recovery opérations

        FORMAT: Instructions claires étape par étape
        """
        
        return self._call_mistral_api(prompt)
    
    def _get_fallback_analysis(self, mineral_map, exploration_data, science_stats):
        """Analyse de repli si l'API n'est pas disponible"""
        mineral_summary = self._summarize_mineral_data(mineral_map)
        
        return f"""
        ⚠️ ANALYSE LOCALE (API MISTRAL NON DISPONIBLE)
        
        CARTE MINÉRALE:
        {mineral_summary}
        
        STRATÉGIE RECOMMANDÉE:
        1. Explorer zones concentration >0.5
        2. Prioriser robots vers régions inexplorées
        3. Échantillonnage systématique cratères
        4. Coordination multi-robots optimisée
        
        RISQUES IDENTIFIÉS:
        - Couverture exploration insuffisante
        - Ressources énergie limitées
        - Communication inter-robots
        """
    
    def _get_fallback_advice(self, current_state, recent_discoveries, mission_goals):
        """Conseils de repli"""
        return """
        CONSEILS STRATÉGIQUES (MODE LOCAL):
        
        🔍 EXPLORATION:
        - Cibler zones adjacentes découvertes
        - Balayage systématique secteurs
        - Prioriser cratères et formations
        
        📊 OPTIMISATION:
        - Rotation robots zones chaudes
        - Conservation énergie déplacements
        - Communication données essentielles
        
        ⚠️ VIGILANCE:
        - Surveillance niveaux batterie
        - Éviter zones obstacles denses
        - Maintenir couverture communication
        """
    
    def _summarize_mineral_data(self, mineral_map):
        """Résume les données minérales pour l'IA"""
        if isinstance(mineral_map, np.ndarray):
            total_minerals = np.sum(mineral_map > 0.1)
            max_concentration = np.max(mineral_map)
            avg_concentration = np.mean(mineral_map[mineral_map > 0])
            
            if mineral_map.ndim == 3:
                mineral_types = ["REE_Oxides", "REE_Silicates", "REE_Phosphates", "REE_Carbonates"]
                type_summary = []
                for i, mineral_type in enumerate(mineral_types):
                    if i < mineral_map.shape[2]:
                        count = np.sum(mineral_map[:, :, i] > 0.1)
                        max_conc = np.max(mineral_map[:, :, i])
                        type_summary.append(f"{mineral_type}: {count} pts, max:{max_conc:.3f}")
            else:
                type_summary = ["Données non disponibles"]
            
            return f"""
            📊 CARTE MINÉRALE:
            • Points détectés: {total_minerals}
            • Concentration max: {max_concentration:.3f}
            • Concentration moy: {avg_concentration:.3f}
            • Distribution: {mineral_map.shape}
            
            🔬 RÉPARTITION:
            {chr(10).join(type_summary)}
            """
        else:
            return f"Données minérales: {str(mineral_map)}"
    
    def _summarize_exploration_data(self, exploration_data):
        """Résume les données d'exploration"""
        if isinstance(exploration_data, dict):
            return f"""
            🚀 PROGRESSION EXPLORATION:
            • Zone couverte: {exploration_data.get('area_covered', 'N/A')}%
            • Distance: {exploration_data.get('distance_traveled', 'N/A')}m
            • Temps: {exploration_data.get('exploration_time', 'N/A')}min
            • Positions: {exploration_data.get('positions_visited', 'N/A')}
            • Robots: {exploration_data.get('active_robots', 'N/A')}
            • Taux découverte: {exploration_data.get('discovery_rate', 'N/A')}%
            """
        else:
            return str(exploration_data)
    
    def _summarize_science_stats(self, science_stats):
        """Résume les statistiques scientifiques"""
        if isinstance(science_stats, dict):
            return f"""
            🔍 STATISTIQUES SCIENTIFIQUES:
            • Minéraux: {science_stats.get('discovered_minerals', 0)}
            • Échantillons HV: {science_stats.get('high_value_samples', 0)}
            • Régions: {science_stats.get('visited_regions', 0)}
            • Score science: {science_stats.get('total_science_value', 0):.1f}
            • Minéraux uniques: {science_stats.get('unique_minerals', 0)}
            • Concentration moy: {science_stats.get('avg_concentration', 0):.3f}
            """
        else:
            return str(science_stats)
    
    def get_system_status(self):
        """Retourne le statut du système"""
        if self.api_available:
            model = self.config.get('model', 'N/A')
            return f"🟢 MISTRAL AI ONLINE - Modèle: {model}"
        else:
            return "🔴 MISTRAL AI OFFLINE - Clé API requise"
    
    def export_mission_data(self, filepath=None):
        """Exporte toutes les données de mission"""
        if not filepath:
            filepath = f"/tmp/ree_mission_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        
        export_data = {
            'export_timestamp': datetime.now().isoformat(),
            'system_status': self.get_system_status(),
            'mission_history': self.mission_history,
            'config': self.config
        }
        
        try:
            with open(filepath, 'w', encoding='utf-8') as f:
                json.dump(export_data, f, indent=2, ensure_ascii=False)
            return f"✅ Données exportées: {filepath}"
        except Exception as e:
            return f"❌ Erreur export: {str(e)}"
    
    def clear_cache(self):
        """Vide le cache des réponses"""
        self.response_cache.clear()
        return "✅ Cache vidé"

# Test du système
def test_system():
    """Teste le système Mistral AI"""
    print("🧪 Test du système Generative AI...")
    
    ai_system = ScienceAISystem()
    print(ai_system.get_system_status())
    
    # Test avec données simulées
    if ai_system.api_available:
        test_data = np.random.rand(10, 10, 4) * 0.6
        exploration = {'area_covered': 45, 'active_robots': 3}
        stats = {'discovered_minerals': 12, 'high_value_samples': 2}
        
        analysis = ai_system.analyze_mission_data(test_data, exploration, stats)
        print(f"📝 Analyse test: {analysis[:200]}...")
    
    return ai_system

if __name__ == "__main__":
    test_system()